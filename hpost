#!/usr/bin/env ruby

# hpost - Hugo Post Creator
# A command-line tool for creating Hugo blog posts with proper front matter

require 'optparse'
require 'date'
require 'yaml'
require 'fileutils'

# Dependency checking
begin
  require 'slugify'
rescue LoadError
  puts "Error: The 'slugify' gem is required but not installed."
  puts "Please install it with: gem install slugify"
  puts "Or add it to your Gemfile: gem 'slugify'"
  exit 1
end

class HPost
  DEFAULT_CONFIG = {
    'posts_dir' => '~/blog/content/posts/',
    'editor' => ENV['EDITOR'] || 'default',
    'preview' => ENV['EDITOR'] || 'default',
    'default_tags' => [],
    'default_category' => [],
    'default_draft' => true
  }.freeze

  attr_reader :options, :config

  def initialize
    @options = {}
    @config = load_config
    @state_file = File.expand_path('~/.config/hpost/.state')
  end

  def run(args)
    parse_options(args)
    
    # Handle --clear-filters
    if @options[:clear_filters]
      File.delete(@state_file) if File.exist?(@state_file)
      puts "Filters cleared."
      return
    end
    
    load_state
    
    case @options[:command]
    when 'list'
      # Save state when listing (or clear it if no filter)
      save_state
      list_posts(@options[:count] || 10, @options[:sort_by_modtime], @options[:filter_tag])
    when 'edit'
      edit_post(@options[:id], @options[:sort_by_modtime], @options[:filter_tag])
    when 'preview'
      preview_post(@options[:id], @options[:sort_by_modtime], @options[:filter_tag])
    else
      create_post
    end
  end

  private

  def load_config
    config_path = File.expand_path('~/.config/hpost/config.yml')
    
    if File.exist?(config_path)
      user_config = YAML.load_file(config_path)
      DEFAULT_CONFIG.merge(user_config)
    else
      # Check environment variable for posts directory
      if ENV['HPOST_DIR']
        DEFAULT_CONFIG.merge('posts_dir' => ENV['HPOST_DIR'])
      else
        DEFAULT_CONFIG
      end
    end
  rescue => e
    puts "Warning: Error loading config file: #{e.message}"
    puts "Using default configuration."
    DEFAULT_CONFIG
  end

  def load_state
    return unless File.exist?(@state_file)
    
    state = YAML.load_file(@state_file)
    
    # Only load state for edit/preview commands if no explicit filter provided
    if ['edit', 'preview'].include?(@options[:command])
      @options[:filter_tag] ||= state['filter_tag']
      @options[:sort_by_modtime] ||= state['sort_by_modtime']
    end
  rescue => e
    # Silently ignore state loading errors
  end

  def save_state
    state_dir = File.dirname(@state_file)
    FileUtils.mkdir_p(state_dir) unless Dir.exist?(state_dir)
    
    if @options[:filter_tag] || @options[:sort_by_modtime]
      # Save current filter state
      state = {
        'filter_tag' => @options[:filter_tag],
        'sort_by_modtime' => @options[:sort_by_modtime]
      }
      File.write(@state_file, state.to_yaml)
    else
      # Clear state when listing with no filters
      File.delete(@state_file) if File.exist?(@state_file)
    end
  rescue => e
    # Silently ignore state saving errors
  end

  def parse_options(args)
    OptionParser.new do |parser|
      parser.banner = "Usage: hpost [options] [command]"
      parser.separator ""
      parser.separator "Commands:"
      parser.separator "  create (default)  Create a new post"
      parser.separator "  list [count]      List recent posts (default: 10)"
      parser.separator "  edit <id>         Edit a post by ID (1-based index from list)"
      parser.separator "  preview <id>      Preview a post by ID (1-based index from list)"
      parser.separator ""
      parser.separator "Options:"

      parser.on("-t", "--title TITLE", "The title of the post") do |o|
        @options[:title] = o
      end

      parser.on("-T", "--tags TAGS", "Comma-delimited tags (e.g. 'ruby,programming')") do |o|
        @options[:tags] = o.split(',').map(&:strip)
      end

      parser.on("-c", "--category CATEGORY", "Comma-delimited categories") do |o|
        @options[:category] = o.split(',').map(&:strip)
      end

      parser.on("-s", "--summary SUMMARY", "Summary for the post") do |o|
        @options[:summary] = o
      end

      parser.on("-d", "--daily", "Create a daily notes post") do
        @options[:type] = 'daily'
        @options[:category] = ['Daily']
        @options[:tags] = ['journal']
        @options[:title] = "Daily notes for #{Date.today.strftime('%Y-%m-%d')}"
      end

      parser.on("-p", "--publish", "Create post as published (not draft)") do
        @options[:draft] = false
      end

      parser.on("--draft", "Create post as draft (default)") do
        @options[:draft] = true
      end

      parser.on("-h", "--help", "Show this help message") do
        puts parser
        exit(0)
      end

      parser.on("-m", "--modtime", "Sort list by modification time instead of date prefix") do
        @options[:sort_by_modtime] = true
      end

      parser.on("-g", "--tag TAG", "Filter list by tag") do |tag|
        @options[:filter_tag] = tag
      end

      parser.on("--clear-filters", "Clear saved filter state") do
        @options[:clear_filters] = true
      end
    end.parse!(args)

    # Handle commands
    if args.any?
      command = args.shift
      case command
      when 'list'
        @options[:command] = 'list'
        @options[:count] = args.first.to_i if args.first
      when 'edit'
        @options[:command] = 'edit'
        @options[:id] = args.first.to_i if args.first
      when 'preview'
        @options[:command] = 'preview'
        @options[:id] = args.first.to_i if args.first
      else
        # If not a recognized command, treat it as part of options
        args.unshift(command)
      end
    end
  end

  def create_post
    validate_create_options!
    
    date = Date.today.strftime("%Y-%m-%d")
    long_date = Time.now.strftime("%Y-%m-%dT%H:%M:%S%z")
    slug = @options[:title].slugify
    
    filename = if @options[:type] == 'daily'
      "#{date}-daily-notes.md"
    else
      "#{date}-#{slug}.md"
    end
    
    posts_dir = File.expand_path(@config['posts_dir'])
    ensure_directory_exists!(posts_dir)
    
    file_path = File.join(posts_dir, filename)
    
    if File.exist?(file_path)
      puts "Post already exists: #{file_path}"
      open_file(file_path)
      return
    end
    
    # Determine draft status: command line option > config > default (true)
    draft_status = if @options.key?(:draft)
      @options[:draft]
    else
      @config['default_draft']
    end

    front_matter = {
      'title' => @options[:title],
      'date' => long_date,
      'draft' => draft_status,
      'categories' => @options[:category] || @config['default_category'],
      'tags' => @options[:tags] || @config['default_tags'],
      'summary' => @options[:summary] || ""
    }
    
    post_content = "#{front_matter.to_yaml}---\n\n"
    
    begin
      File.write(file_path, post_content)
      puts "Created: #{file_path}"
      open_file(file_path)
    rescue => e
      puts "Error creating post: #{e.message}"
      exit 1
    end
  end

  def list_posts(count, sort_by_modtime = false, filter_tag = nil)
    posts_dir = File.expand_path(@config['posts_dir'])
    
    unless Dir.exist?(posts_dir)
      puts "Error: Posts directory not found: #{posts_dir}"
      exit 1
    end
    
    # Get all markdown files
    all_posts = Dir.glob(File.join(posts_dir, "*.md"))
    
    # Filter by tag if specified
    if filter_tag
      all_posts = all_posts.select { |post| post_has_tag?(post, filter_tag) }
    end
    
    if sort_by_modtime
      # Sort by modification time (newest first)
      posts = all_posts.sort_by { |f| File.mtime(f) }.reverse.take(count)
      sort_method = "modification time"
    else
      # Sort by date prefix in filename (newest first)
      # Expected format: YYYY-MM-DD-slug.md
      posts = all_posts.select { |f| File.basename(f) =~ /^\d{4}-\d{2}-\d{2}-/ }
                       .sort_by { |f| File.basename(f) }
                       .reverse
                       .take(count)
      sort_method = "date prefix"
    end
    
    if posts.empty?
      if filter_tag
        puts "No posts found with tag '#{filter_tag}' in #{posts_dir}"
      else
        puts "No posts found in #{posts_dir}"
      end
      return
    end
    
    # Build description
    description_parts = ["Recent posts"]
    if filter_tag
      description_parts << "with tag '#{filter_tag}'"
      # Check if filter came from state
      if File.exist?(@state_file) && !@options.key?(:filter_tag)
        description_parts << "(filter from previous list)"
      end
    end
    description_parts << "(sorted by #{sort_method}, newest first)"
    
    puts description_parts.join(" ") + ":"
    puts
    
    posts.each_with_index do |post, index|
      basename = File.basename(post)
      
      # Extract date for display
      if basename =~ /^(\d{4}-\d{2}-\d{2})-/
        display_date = $1
      else
        # Fallback to modification time if no date prefix
        display_date = File.mtime(post).strftime("%Y-%m-%d")
      end
      
      # Try to extract title from front matter
      title = extract_title(post) || basename
      
      printf "%3d. [%s] %s\n", index + 1, display_date, title
    end
  end

  def edit_post(id, sort_by_modtime = false, filter_tag = nil)
    unless id && id > 0
      puts "Error: Please provide a valid post ID (use 'hpost list' to see posts)"
      exit 1
    end
    
    posts_dir = File.expand_path(@config['posts_dir'])
    all_posts = Dir.glob(File.join(posts_dir, "*.md"))
    
    # Filter by tag if specified
    if filter_tag
      all_posts = all_posts.select { |post| post_has_tag?(post, filter_tag) }
    end
    
    if sort_by_modtime
      # Sort by modification time (newest first)
      posts = all_posts.sort_by { |f| File.mtime(f) }.reverse
    else
      # Sort by date prefix in filename (newest first)
      posts = all_posts.select { |f| File.basename(f) =~ /^\d{4}-\d{2}-\d{2}-/ }
                       .sort_by { |f| File.basename(f) }
                       .reverse
    end
    
    if posts.empty?
      if filter_tag
        puts "Error: No posts found with tag '#{filter_tag}'"
      else
        puts "Error: No posts found"
      end
      exit 1
    end
    
    if id > posts.length
      puts "Error: Post ID #{id} not found (only #{posts.length} posts available)"
      puts "Hint: Use 'hpost list#{filter_tag ? " --tag #{filter_tag}" : ""}' to see available posts"
      exit 1
    end
    
    post_path = posts[id - 1]
    puts "Editing: #{File.basename(post_path)}"
    open_file(post_path)
  end

  def preview_post(id, sort_by_modtime = false, filter_tag = nil)
    unless id && id > 0
      puts "Error: Please provide a valid post ID (use 'hpost list' to see posts)"
      exit 1
    end
    
    posts_dir = File.expand_path(@config['posts_dir'])
    all_posts = Dir.glob(File.join(posts_dir, "*.md"))
    
    # Filter by tag if specified
    if filter_tag
      all_posts = all_posts.select { |post| post_has_tag?(post, filter_tag) }
    end
    
    if sort_by_modtime
      # Sort by modification time (newest first)
      posts = all_posts.sort_by { |f| File.mtime(f) }.reverse
    else
      # Sort by date prefix in filename (newest first)
      posts = all_posts.select { |f| File.basename(f) =~ /^\d{4}-\d{2}-\d{2}-/ }
                       .sort_by { |f| File.basename(f) }
                       .reverse
    end
    
    if posts.empty?
      if filter_tag
        puts "Error: No posts found with tag '#{filter_tag}'"
      else
        puts "Error: No posts found"
      end
      exit 1
    end
    
    if id > posts.length
      puts "Error: Post ID #{id} not found (only #{posts.length} posts available)"
      puts "Hint: Use 'hpost list#{filter_tag ? " --tag #{filter_tag}" : ""}' to see available posts"
      exit 1
    end
    
    post_path = posts[id - 1]
    puts "Previewing: #{File.basename(post_path)}"
    preview_file(post_path)
  end

  def extract_title(file_path)
    content = File.read(file_path)
    if content =~ /^title:\s*["']?(.+?)["']?\s*$/m
      $1
    else
      nil
    end
  rescue
    nil
  end

  def post_has_tag?(file_path, tag)
    content = File.read(file_path)
    
    # Extract tags from YAML front matter
    if content =~ /^tags:\s*\n((?:\s*-\s*.+\n)+)/m
      tags_section = $1
      tags = tags_section.scan(/^\s*-\s*(.+)$/).flatten.map(&:strip)
      tags.any? { |t| t.downcase == tag.downcase }
    elsif content =~ /^tags:\s*\[(.+)\]/m
      # Handle inline array format
      tags = $1.split(',').map { |t| t.strip.gsub(/["']/, '') }
      tags.any? { |t| t.downcase == tag.downcase }
    else
      false
    end
  rescue
    false
  end

  def validate_create_options!
    unless @options[:title]
      puts "Error: Title is required (use -t or --title)"
      puts "Use 'hpost --help' for usage information"
      exit 1
    end
  end

  def ensure_directory_exists!(dir)
    unless Dir.exist?(dir)
      puts "Posts directory not found: #{dir}"
      print "Create it? (y/n): "
      response = gets.chomp.downcase
      
      if response == 'y'
        FileUtils.mkdir_p(dir)
        puts "Created directory: #{dir}"
      else
        puts "Exiting without creating post."
        exit 1
      end
    end
  end

  def open_file(path)
    editor = @config['editor']
    
    if editor && editor != 'default'
      # Use configured editor - split on spaces to handle arguments
      cmd_parts = editor.split(' ')
      system(*cmd_parts, path)
    else
      # Use platform-specific open command
      case RUBY_PLATFORM
      when /darwin/
        system('open', path)
      when /linux/
        system('xdg-open', path) || system("${EDITOR:-vi}", path)
      when /mingw|mswin|cygwin/
        system('start', path)
      else
        puts "Unable to open file automatically."
        puts "Please open: #{path}"
        puts "Set your preferred editor in ~/.config/hpost/config.yml"
      end
    end
  end

  def preview_file(path)
    preview_cmd = @config['preview']
    
    if preview_cmd && preview_cmd != 'default'
      # Use configured preview tool - split on spaces to handle arguments
      cmd_parts = preview_cmd.split(' ')
      system(*cmd_parts, path)
    else
      # Try common preview tools in order of preference
      preview_tools = [
        ['glow', '-p'],      # Glow with pager
        ['mdless'],          # mdless
        ['bat', '--style=plain'],  # bat with plain style
        ['less'],            # fallback to less
        ['cat']              # ultimate fallback
      ]
      
      tool_found = false
      preview_tools.each do |tool_parts|
        tool = tool_parts.first
        if system("which #{tool} > /dev/null 2>&1")
          system(*tool_parts, path)
          tool_found = true
          break
        end
      end
      
      unless tool_found
        # Last resort: use editor
        puts "No preview tool found. Using editor..."
        open_file(path)
      end
    end
  end
end

# Run the application
if __FILE__ == $0
  hpost = HPost.new
  hpost.run(ARGV)
end